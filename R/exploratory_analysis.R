
##' @title Empirical variogram
##' @description Computes the empirical variogram using ``bins'' of distance provided by the user.
##' @param data an object of class \code{sf} containing the variable for which the variogram
##' is to be computed and the coordinates
##' @param variable a character indicating the name of variable for which the variogram is to be computed.
##' @param bins a vector indicating the `bins` to be used to define the classes of distance used in the computation of the variogram. 
##' By default \code{bins=NULL} and bins are then computed as \code{seq(0, d_max/2, length=15)} where \code{d_max} is the maximum distance observed in the data.
##' @param n_permutation a non-negative integer indicating the number of permutation used to compute the 95% confidence
##' level envelope under the assumption of spatial independence. By default \code{n_permutation=0}, and no envelope is generated.
##' 
##' @return an object of class 'variogram' which is a list containing the following components
##' @return \code{dist_class} the classes of distances based on the provided values for \code{bins}
##' @return \code{v} the variogram values
##' @return \code{n} the number of pairs of observations within each bin
##' @return \code{mid_points} the middle points of the classes of distance.
##' @return \code{lower_bound} the lower values of the 95% envelope generated by the random permutations of the variogram values (if \code{n_permutation=0} this component is \code{NULL}).
##' @return \code{upper_bound} the upper values of the 95% envelope generated by the random permutations of the variogram values (if \code{n_permutation=0} this component is \code{NULL}).
##' @author Emanuele Giorgi \email{e.giorgi@@lancaster.ac.uk}
##' @author Claudio Fronterre \email{c.fronterr@@lancaster.ac.uk}
##' @export
##' 

s_variogram <- function(data, variable, bins = NULL,
                      n_permutation = 0) {

  
  if(n_permutation < 0 | 
     n_permutation != round(n_permutation)) stop("n_permutation must be a positive integer number")
  
  coords <- st_coordinates(data)
  d <- as.numeric(dist(coords))
  v <- (as.numeric(dist(data[[variable]])) ^ 2) / 2 
  vario_df <- tibble(d, v)
  if(is.null(bins)) {
    max.v <- max(d)
    bins <- seq(0, max.v, length=15)
  }
  mid_points <- bins[-length(bins)] + (bins[2] - bins[1]) / 2
  
  vario_df$dist_class <- cut(vario_df$d, breaks = bins, 
                             include.lowest = TRUE, right = TRUE)
  vario_df <- vario_df %>%
    filter(d < max(d)) %>% 
    group_by(dist_class) %>% 
    summarise(v = mean(v), n = n()) %>% 
    mutate(mid_points = mid_points)
  
  if(n_permutation > 0) {
    v_perm <- matrix(NA, nrow=nrow(vario_df),ncol = n_permutation)
    for(i in 1:n_permutation) {
      v_i <- sample(v)
      
      vario_df_i <- tibble(d, v_i)
      
      vario_df_i$dist_class <- cut(vario_df_i$d, breaks = bins, 
                                   include.lowest = TRUE, right = TRUE)
      
      v_perm[,i] <- aggregate(v_i ~ dist_class, data = vario_df_i, FUN = mean)$v_i
    }
    vario_df$lower_bound <- apply(v_perm, 1, function(x) quantile(x, 0.025))
    vario_df$upper_bound <- apply(v_perm, 1, function(x) quantile(x, 0.975))
  }
  
  class(vario_df) <- "variogram"
  return(vario_df)
}